编译和链接
	预编译过程主要处理源代码文件里以“#”开始的预处理命令，并且约定了处理规则。
预编译命令gcc –E，生成.i文件,这个文件里面宏定义已经展开，include的文件也已经放进来。我们能用预编译来检查我们源代码文件里使用的预处理命令是否正确。
	编译过程是对预处理完后的.i文件进行词法分析、语法分享、语义分析和优化后生成响应汇编语言文件。
	汇编是将汇编文件翻译成机器可执行的指令。
	链接实现把各个模块组合成为可执行程序，这些模块相互独立又相互联系，相互独立是说我们可以单独去修改、重用它，相互联系是说他们之间是可以相互引用，链接的主要内容是把各个模块之间的相互引用部分处理好，连接过程主要包括地址和空间分配、符号决议和重定位等。
	实际上，gcc命令是这些后台程序的包装，编译和预编译程序cc1，汇编器as，连接器ld等
编译过程分解
	扫描器，词法分析程序lex，将源代码中的字符串序列分割成一系列记号。
	语法分析器，语法分析程序yacc，对记号分析，生成语法树。
	语义分析器，语法树上补充表达式含义，比如需要类型转换，类型不匹配错误报告等
	源代码优化器，会把优化了的语法树转换成中间代码，与机器无关。
	代码生成器和目标代码优化器
目标文件
	程序源代码被编译后主要分成两个段：程序指令和程序数据，代码段属于程序指令，数据的和、bssd段属于程序数据。
	Elf（Executable and Linking Format）格式目标文件的结构和内容，使用命令objdump –h可以了解到文件内的各个段长度和在文件中的偏移位置。使用命令objdump –s –d 可以了解到各个段的内容以十六进制表示及代码的反汇编，
	Elf文件结构划分为Elf文件头和段表，使用命令readelf –h可以了解文件头包含对elf文件基本属性的详细描述，文件头结构和相关常数的定义在文件里？usr/include/elf.h。
	使用命令readelf –S可以了解到段表对各个段属性的详细描述，段名只是在编译和链接过程时有意义，决定段属性的是段的类型和标识。链接过程需要对目标文件里的部分进行重定位。
	在链接中，目标文件的拼合实际上是对目标文件里的地址的引用，地址即函数和变量的地址，这时，函数和变量统称为符号，是在连接中的“粘合剂”，那么，每一个目标文件都有它的符号表，每一个符号都有一个相对应的值。我们对符号归类，分为全局符号，局部符号，段名，行号信息。而链接关心的是全局符号，其他类型的符号它看不到。
	分析两个问题，
	一个问题是，链接时，符号重复定义错误？
	一个问题是，链接时，符号未定义错误？

生产C语言源代码文件
a.c
#include <stdio.h>
extern int shared ;
int main()
{
	int a = 100;
	swap(&a, &shared);
}
b.c
int shared = 1;
void swap(int *a, int *b)
{
        *a ^= *b ^= *a ^= *b;
}
生产目标文件
gcc -c a.c
gcc -c b.c

生产可执行文件
ld a.o b.o -e main -o ab
关于“两步链接”方法，第一步，做空间和地址分配，这里我们关注虚拟地址空间的分配。第二步，做符号解析和重定位。
分析第一个问题：链接前后地址分配的情况，objdump -h a.b...。
	得出的结果：链接前，目标文件的各个段没有分配地址空间。链接后，可执行文件的各个段分配了虚拟地址，而虚拟地址空间的大小是累加和,一般，虚拟地址和加载地址是一样的。同时符号地址也确定，符号地址应该是符号所在段的地址加一个偏移量就行了，而这个偏移量应该是指符号所在的段的偏移。
	另外一个疑问，虚拟地址不是从0地址开始，为什么？
	重定位过程同时进行了符号解析，那么重定位过程会利用到已经确定下来的符号虚拟地址，
	静态链接库，简单的说它就是一组目标文件的集合，就是很多个目标文件经过压缩打包后形成的一个文件，Linux系统中最常用的C语言静态库是/usr/lib/libc.a。我们使用工具ar –x <filename>把文件<filename>从归档里取出来。
	我们使用命令“gcc -static --verbose -fno-builtin ../hello2.c”来将整个编译连接过程的中间步骤给打印出来。
	接下来，我们将要讲到的是连接过程控制的一种灵活的方法，那就是链接脚本。
链接时，我们可以使用命令“ld –T <ldscript>”使用链接脚本，若没有指定，那么链接使用默认的脚本，我们可以使用命令“ld –verbose”查看这个默认脚本。
	下面我们就通过一个示例来演示链接脚本的链接过程控制。
	第一步，生产源代码文件TinyHelloWord.c，如下
char *str="Hello world!\n";
void print()
{
	asm("movl $13, %%edx \n\t"
		"movl $0, %%ecx \n\t"
		"movl $0, %%ebx \n\t"
		"movl $4, %%eax \n\t"
		"int $0x80 		\n\t"
		::"r" (str):"edx","ecx","ebx");
}
void exit()
{
  	asm("movl $42, %ebx \n\t"
		"movl $1, %eax \nt"
		"int $0x80 \n\t");
}
void nomain()
{
 	print();
	exit();
}
	第二步，使用普通命令行的方式编译链接TinyHelloworld.c
我们先解释一下将要用到的几个gcc编译连接选项
1，-fno-builtin，它关闭gcc内置函数功能
2，-static，使ld用静态链接的方式来链接程序，而不是用默认的动态链接方式
3，-e，指定程序的入口函数
我们使用命令“gcc –c –fno-builtin TinyHelloworld.c”编译
我们使用命令“ld -static -e nomain -o TinyHelloworld TinyHelloworld.o”链接
	第三步，我们在编译链接过程中使用ld链接脚本TinyHelloWorld.lds
ENTRY(nomain)
SECTIONS
{
	.=0x08048000+SIZEOF_HEADERS 	@将当前的虚拟地址设置成0x08048000+SIZEOF_HEADERS
	tinytext	:	{*(.text)*(.data)*(.rodata)}	
@所有输入文件中的名字是.text，.data，.rodata 的段以此的合并到输出文件的“tinytext”
	/DISCARD/	:	{*(.comment)}
@ .comment段丢弃
}

装载
	静态载入方式是程序运行所需要的指令和数据统统的载入的内存里面，这种方式，要求内存大小随着程序大小呈线性增长，增大内存，成本太贵了，基于程序运行时的局部性原理，想到另外一种办法是，程序运行最常用的部分常驻在内存，不太常用的数据在磁盘里存放，程序运行需要的时候再载入进来，这是动态载入方法。
	动态载入方式分为覆盖载入和页映射方式，覆盖载入基于模块之间的调用依赖关系而建立的一颗关系树，从树的根到树的叶子形成一次覆盖载入。页映射是分而治之思想的运用，它将程序的指令和数据以“页”为单位进行划分，实例，如何在16k的物理内存里运行一个32k的程序？
1，按页划分：32*1024/4096=8。2，装载管理器会根据程序运行需要的指令和数据所属页来决定把哪一个页装载到内存。3，对于内存已满时，有特定的算法做处理。
	第一步，页映射，实现虚拟空间到物理内存的映射
	第二步，读取可执行文件头，实现虚拟空间到可执行文件的映射
	第三步，定义程序的入口地址，运行程序
我们把进程虚拟空间的一个段叫做VMA即虚拟内存区域，在操作系统看来，它不关心可执行文件段中的内容，它更关心对其中的段的操作权限，比如，它期望把可读可写权限的数据段和.bss段映射到一个VMA，那么，优化的做法是把具有相同权限属性的段映射到同一个虚拟空间，下面映射可执行文件的示例：
	第一步，生产一个源代码文件sectionMappint.c
	第二步，用静态链接的方式将他编译链接成可执行文件sectionMappint.elf，执行命令
“gcc -static sectionMapping.c -o sectionMapping.elf”
	第三步，我们使用命令“readelf -l sectionMapping.elf”查看可执行文件的程序头，这部分信息描述了ELF文件如何被操作系统映射到虚拟地址空间，这个文件头表的信息和和程序表结构phdr内容一致。我们查看文件/proc/<pid>/map可以获取映射信息。

	为什么要动态链接？静态链接带来两个问题，一个问题是极大地浪费内存和磁盘空间，这表现在 多道程序共用库时，那么就会在磁盘和内存里产生这个库的多道副本。另一个问题是更新困难。
动态链接的基本思想是：我们不对那些组成程序的目标文件进行链接，而是把程序拆分成若干个相互独立的模块，在程序运行时才进行链接，也即是说，这个链接过程推迟到了程序运行时进行。
动态链接的优势体现在程序可扩展性和兼容性，这是以牺牲程序运行时性能为代价的。
	Linux系统下，动态链接库是以扩展名.so表示
	Windows系统下，动态链接库是以扩展名.dll表示
	下面是一个动态链接的示例：
第一步，生产一项工程
/*Program1.c*/
#include "Lib.h"

int main()
{
  foobar(1);
  return 0;
}
/*Program2.c*/
#include "Lib.h"

int main()
{
  foobar(2);
  return 0;
}
/*Lib.c*/
#include <stdio.h>

void foobar(int i)
{
  printf("Printing from Lib.so %d\n", i);
}
/*Lib.h*/
#ifndef LIB_H
#define LIB_H

void foobar(int i);

#endif
第二步，生产出两个程序Program1和Program2
gcc -fPIC -shared -o Lib.so Lib.c
gcc -o Program1 Program1.c ./Lib.so
gcc -o Program2 Program2.c ./Lib.so
链接器要分辨程序的主要部分（即可执行文件）里引用的符号是在其他静态目标模块里定义的还是在某一个共享对象文件（即程序所依赖的模块）里定义的，在动态共享对象文件里面有完整的符号信息。
我们查看一下动态链接程序运行时地址空间分布
cat /proc/13643/maps
从这里的信息看到多了几个映射，
他们是Lib.so、/lib/ld-2.12.90.so、/lib/libc-2.12.90.so
我们再来看一下这一个共享对象Lib.so的装载信息
readelf -l Lib.so
从这里的信息看到的是共享对象最终装载地址不确定，我们是把共享对象的重定位推迟到了装载时，叫做装载时重定位，这没法让同一份指令被多个进程共享，就这一个问题来看的话，我们希望程序模块在装载时其中的共享指令部分不会因为装载地址的改变而改变，那么，我们归纳了四种情况之下，我们使用地址无关技术是如何达成我们的这一个期望的？
第一种情况，模块内部调用和跳转，调用函数与被调用者的相对位置的固定的特点使得在模块内部调用和跳转是与模块被装载到哪里无关。
第二种情况，访问模块内部的数据，任何一条指令与模块内部数据的相对位置的固定的特点使得模块内部数据的访问与模块被装载到哪里无关。
第三种情况，模块外部调用和跳转，我们在数据段里面建立一个叫做全局偏移表（GOT）的东西，这个东西记录全局变量的地址，而全局变量的地址是装载时决定的，代码地址无关就是说我的代码在访问这个全局变量的时候，我是去查GOT表已间接获得了这个变量的值。
第四种情况，模块外部数据访问，
动态链接的实现过程：第一步，装载可执行文件，不会把控制权就交给可执行文件，因为可执行文件还依赖于很多共享对象。第二步，装载共享对象。第三步，把控制权交给动态连接器的入口地址，动态链接器做对自己的一些初始化，对可执行文件进行动态链接工作，完了后才把控制权交给可执行文件的入口地址，程序正式开始执行。
我们使用命令“readelf -l Program1 | grep interpreter”查看动态链接器的路径
我们使用命令“readelf -d Lib.so”获取.dynamic段的基本信息，是动态链接下
ＥＬＦ文件的“文件头”。
我们使用命令“readelf -sD Lib.so”查看动态链接符号表.dynsym,这个段提供了符号的导入导出关系信息。
我们使用命令“readelf -r Lib.so”查看动态链接文件里面的重定位表
动态链接初始化堆栈，这个堆栈里面提供了什么信息
动态链接步骤概况起来分为3步
第一步，动态链接器自举，要求：
第一，	动态链接器不能依赖于其他任何共享对象
第二，	动态连接器所需要的所有全局和静态变量的重定位工作有自己完成
第二步，动态连接器自举完后，会把可执行文件的符号和动态连接器自身的符号合并，合并后的符号表我们叫做是全局符号表，这个过程中，必然会发生这样的一件事情，就是一个共享对象的全局符号在另一个共享对象里已经出现过了，这时，后出现的会被先出现覆盖，我们叫做全局符号介入。所以我们尽量避免符号重名。
第三步，重定位和初始化

动态链接器的实现
lrwxrwxrwx. 1 root root 13  8月  9 2011 /lib/ld-linux.so.2 -> ld-2.12.90.so
ld-2.12.90.so这个就是Linux的动态连接器，它是一个共享对象文件，也是一个可执行文件。

Linux共享库

接下来我们探讨在程序运行时，背后隐藏的秘密
程序运行的环境包括内存，运行库和系统调用（其实是程序和系统内核交互的接口（或者是通信的中介））
运行环境之内存，以i386体系结构为例说明，整体上来看，32位系统提供4GB寻址空间，最高的1GB给内核，剩下的2GB或3GB给用户，我们关心的是用户空间及程序内存的布局，程序内存的布局大体上来看，最高地址是数兆字节的“栈”，栈不够时，允许它向低地址生长，直到unused内存被占用完，从0x40000000地址开始往上是用来装载动态链接库，它之下是“堆”，在某些情况，堆没有固定的存储区域，但应该是在低地址位置，那么，堆不够时，允许向高地址生长，直到unused内存被占用完，还有就是可执行文件映像，关于这一块内存，我们先前探讨过了，接下来我们探讨栈和堆。
栈是一个特殊的容器，这个容器的底部叫做栈低，顶部叫做栈顶，栈顶的位置由esp寄存器确定，它的属性是，数据压入时，栈顶的位置下降的，数据弹出时，栈顶的位置是上升的，这意味着，我们可以主动改变esp寄存器来实现栈空间的分配和回收。
栈举足轻重的作用体现在，程序运行时，它存储一个函数调用所需要维护的信息，这时，栈被叫做是堆栈帧或活动记录，当发生一个函数调用时，应该需要存储的信息基本上包括：
1，	函数返回地址和参数
2，	临时变量
3，	保存的上下文
函数调用发生了哪些事件，我们以下面的一个示例来说明
在知道了函数调用发生的事件之后，我们应该还要明白，函数的调用方和被调用方他们在函数如何调用问题上要达成一致，这个一致的想法我们叫做是“调用惯例”，调用惯例规定了如下几个方面的内容:
1,
什么是堆，它是具有特殊属性的一个集合，什么样的内存区域会被识别为堆呢？
第一个特点，这块内存区域是产生于程序的请求。
第二个特点，这块内存区域会一直保持有效，直到程序放弃对她的使用。
“堆”的生产方法，即运行库如何向操作系统批发内存？
“堆”的分配算法，即运行库如何把从操作系统批发到的内存分配给程序？

Ld链接脚本语法

	语句之间用“；”分隔，命令语句也允许使用换行结束
	命令语句，格式为 关键字（参数），重点需要看SECTIONS命令，它负责定义连接过程中段转换过程。
	赋值语句

